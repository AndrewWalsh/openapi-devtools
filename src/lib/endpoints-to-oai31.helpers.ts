import type { Schema } from "genson-js";
import {
  ContentObject,
  HeaderObject,
  HeadersObject,
  MediaTypeObject,
  OpenApiBuilder,
  ParameterObject,
  RequestBodyObject,
  ResponseObject,
  ResponsesObject,
  SecuritySchemeObject,
} from "openapi3-ts/oas31";

import { Options } from "./RequestStore.js";
import { Authentication, AuthType, Endpoint, Example, Leaf, PartType } from "../utils/types.js";

export const createSecuritySchemeTypes = (
  auth?: Authentication,
): SecuritySchemeObject | undefined => {
  if (!auth) return;
  const isBearer = auth.authType === AuthType.HTTP_HEADER_BEARER;
  const isBasic = auth.authType === AuthType.HTTP_HEADER_BASIC;
  const isDigest = auth.authType === AuthType.HTTP_HEADER_DIGEST;
  if (isBearer || isBasic || isDigest) {
    const httpAuth: SecuritySchemeObject = {
      type: auth.type,
      in: auth.in,
      scheme: auth.scheme,
    };
    return httpAuth;
  }
  const isAPIKeyHeader = auth.authType.startsWith(AuthType.APIKEY_HEADER_);
  const isAPIKeyCookie = auth.authType.startsWith(AuthType.APIKEY_COOKIE_);
  if (isAPIKeyHeader || isAPIKeyCookie) {
    const apiKeyHeader: SecuritySchemeObject = {
      type: auth.type,
      in: auth.in,
      name: auth.name,
    };
    return apiKeyHeader;
  }
};

export const shouldIncludeRequestBody = (method: string) => {
  return !new Set(["get", "delete", "head"]).has(method.toLowerCase());
};

type RequestType = Leaf["methods"]["get"]["request"];
export const createRequestTypes = (
  requestType: RequestType,
  options: Options,
  examples?: Example[],
) => {
  if (!requestType) return;
  const contentObject: ContentObject = {};
  Object.entries(requestType).forEach(([mediaType, data]) => {
    const mediaTypeObject: MediaTypeObject = {
      schema: data.body,
      ...(!!options.enableMoreInfo && { example: data.mostRecent }),
    };
    contentObject[mediaType] = mediaTypeObject;
  });
  const requestBodyObject: RequestBodyObject = {
    content: contentObject,
  };
  Object.entries(requestType).forEach(([mediaType, data]) => {
    const mediaTypeObject: MediaTypeObject = {
      schema: data.body,
      ...(!!options.enableMoreInfo && { example: data.mostRecent }),
      examples: {
        ...examples?.reduce((acc: { [key: string]: { value: unknown }}, example) => {
          acc[example.id] = {
            value: example.request,
          };
          return acc;
        }, {}),
      },
    };
    contentObject[mediaType] = mediaTypeObject;
  });

  return requestBodyObject;
};

type ResponseType = Leaf["methods"]["get"]["response"];
export const createResponseTypes = (
  responseType: ResponseType,
  headers: Schema | undefined,
  options: Options,
  examples?: Example[],
) => {
  // Create response headers
  const headersObject: HeadersObject = {};

  if (headers && headers.properties) {
    if (headers.properties) {
      Object.entries(headers.properties).forEach(([name, schema]) => {
        const headerObj: HeaderObject = {
          required: false,
          schema,
        };
        headersObject[name] = headerObj;
      });
    }
  }

  // Initialise responses object, set response objects from status codes
  const responsesObject: ResponsesObject = {};
  const responseExamples = examples?.reduce((acc: { [key: string]: { value: unknown }}, example) => {
      acc[example.id] = {
        value: example.response,
      };
      return acc;
    }, {});
  

  console.log("response examples", responseExamples);
  Object.entries(responseType).forEach(([statusCode, mediaTypeObj]) => {
    Object.entries(mediaTypeObj).forEach(([mediaType, data]) => {
      const contentObject: ContentObject = {};
      const mediaTypeObject: MediaTypeObject = {
        schema: data.body,
        ...(!!options.enableMoreInfo && { example: data.mostRecent }),
        examples: responseExamples
      };
      contentObject[mediaType] = mediaTypeObject;
      const responseObject: ResponseObject = {
        content: contentObject,
        description: "",
        headers: headersObject,
      };
      responsesObject[statusCode] = responseObject;
    });
  });

  return responsesObject;
};

// export const createResponsesObj = (statusCodeObj: Array<[statusCode: string, respObj: ResponseObject]>) => {
//   const responsesObject: ResponsesObject = {
//     [statusCode]: responseObject,
//   };

//   return responsesObject;
// };

export const createBuilderAndDocRoot = (
  endpoints: Array<Endpoint>,
): OpenApiBuilder => {
  const builder = OpenApiBuilder.create({
    openapi: "3.1.0",
    info: {
      title: "OpenAPI Specification",
      version: "1.0.0",
      description: `A specification generated by [openapi-devtools](https://github.com/AndrewWalsh/openapi-devtools). Contains ${
        endpoints.length
      } endpoint${endpoints.length === 1 ? "" : "s"}.`,
    },
    paths: {},
  });
  return builder;
};

export const createPathParameterTypes = (
  endpoint: Endpoint,
): Array<ParameterObject> => {
  const dynamicParts = endpoint.parts.filter(
    ({ type }) => type === PartType.Dynamic,
  );

  // Combine examples from all methods of the endpoints object.
  const examples: Example[] | undefined = Object.values(endpoint.data.methods).reduce((acc: Example[], method) => {
    if (method.examples) {
      acc.push(...method.examples);
    }
    return acc;
  }, []);

  const parameters: ParameterObject[] = dynamicParts.map(({ part: name }) => {
    const parameterExamples = examples?.reduce((acc: { [key: string]: { value: unknown } }, example) => {
      const dynamicPartIndex = endpoint.parts.findIndex(
        (part) => part.type === PartType.Dynamic && part.part === name
      );
      if (dynamicPartIndex !== -1) {
        // +1 is added as dynamic parts index removes first slash
        const parameterValue = example.path.split("/")[dynamicPartIndex+1];
        acc[example.id] = { value: parameterValue };
      }
      return acc;
    }, {});

    return {
      name,
      in: "path",
      required: true,
      schema: { type: "string" },
      examples: parameterExamples,
    };
  });

  return parameters;
};

export const createQueryParameterTypes = (
  queryParameters: Schema | undefined,
  examples?: Example[],
): Array<ParameterObject> => {
  if (!queryParameters?.properties) return [];
  const namesAndSchemas = Object.entries(queryParameters.properties);
  return namesAndSchemas.map(([name, schema]) => {
    const parameterObject: ParameterObject = {
      name,
      in: "query",
      required: false,
      schema,
      examples: {
        ...examples?.reduce((acc: { [key: string]: { value: unknown }}, example) => {
          acc[example.id] = {
            value: (example.query_params as { [key: string]: unknown })?.[name],          };
          return acc;
        }, {}),
      },
    };
    return parameterObject;
  });
};

// Format THIS_TXT_STR to this text str
export const formatAuthType = (str: string) => {
  return str.toLowerCase();
};
